Print["setting history length to 1"];
$HistoryLength=1;
Get["pathSetup.mth"]
Get["AMASeriesRepresentation`"]
Print["preemscstomma"]
Get["emscsToMma`"]
Get["betterRBC`"]
Get["betterRBCTrips`"]
phiMat=getPhi[linModBetter]
fMat=getF[linModBetter]
tErrMat=truncErrorMat[fMat,phiMat,0]
tErrMatMax=Norm[tErrMat,Infinity]


actualErrs[approxDR_Function,xeps:{kk_?NumberQ,tt_?NumberQ,ee_?NumberQ}]:=
With[{approxVals=(approxDR @@ {ig,kk,ig,tt,ee})[[Range[4]]],
actualVals=simpRBCExactDRBetter@@ {ig,kk,ig,tt,ee}},
(-1)*Abs[Flatten[(approxVals-actualVals)]]]


approxErrs[approxDR_Function,approxDRCE_Function,
xeps:{kk_?NumberQ,tt_?NumberQ,ee_?NumberQ}]:=
Module[{approxVals=approxDR[99,kk,99,tt,ee][[Range[4]]]},
(-1)*Abs[Flatten[(tErrMat. 
Transpose[{eqnsCompiledBetter @@ makeArgs[{approxDR,approxDRCE},xeps]}])]]]


approxErrsK[approxDR_Function,approxDRCE_Function,theK_Integer,
xeps:{kk_?NumberQ,tt_?NumberQ,ee_?NumberQ}]:=
Module[{approxVals=approxDR[99,kk,99,tt,ee][[Range[4]]]},
(-1)*Abs[Flatten[(tErrMat. 
Transpose[{checkPt[approxDR,approxDRCE,theK,xeps]}])]]]


makeArgs[{adr_,adrce_},{kk_?NumberQ,tt_?NumberQ,ee_?NumberQ}]:=
Module[{},
With[{xt=Flatten[adr[ig,kk,ig,tt,ee]][[Range[4]]]},
With[{xtp1=Flatten[adrce@@xt][[Range[4]]]},
Append[Join[{999,kk,999,tt},xt,xtp1],ee]]]]



smolRng=#[[{2,3}]]&/@Drop[aGSpecBetter,2][[1]];
aDir="resDir/"
fNameString[approx_?VectorQ,iters_Integer,theK_Integer,numKern_Integer]:=
StringReplace[aDir<>"forBetterRBC-"<>ToString[approx]<>"Iters"<>ToString[iters]<>"theK"<>ToString[theK]<>"host-"<>$MachineName<>"numKern"<>ToString[numKern],{" "->"","{"->"-","}"->"-"}];


kl=betterRBC`Private`kLow 
kh=betterRBC`Private`kHigh
tl=betterRBC`Private`thLow
th=betterRBC`Private`thHigh
sl=betterRBC`Private`sigLow
sh=betterRBC`Private`sigHigh


Options[checkPt]={"Traditional"->False}
checkPt[adr_,adrce_,theK_Integer,aPt:{kk_?NumberQ,tt_?NumberQ,eps_?NumberQ},
opts:OptionsPattern[]]:=
Module[{},
If[OptionValue["Traditional"],
xtm1eps=Flatten[fillIn[{{},{1,3},aPt}]];
xzt=adr @@ xtm1eps;
xztp1=(adrce @@ Flatten[xzt])[[Range[4]]];
tradArg=Flatten[
Join[Drop[xtm1eps,-1],xzt[[Range[4]]],xztp1[[Range[4]]],{eps}]];
(*Print["tradArg:",tradArg];*)
eqnsCompiledBetter @@ tradArg,
xtm1eps=Flatten[fillIn[{{},{1,3},aPt}]];
xzt=adr @@ xtm1eps;
xkzkFunc=
genLilXkZkFunc[linModBetter,{adrce,theK},xzt[[Range[4]]]];
xkApply=Flatten[xkzkFunc @@ Join[xtm1eps,Flatten[xzt[[4+Range[4]]]]]];
eqnsCompiledBetter @@ xkApply]]




doIt[approx_?VectorQ,iters_Integer,theK_Integer]:=
Module[{ptErg,tfErg,plyErg,iplyErg,dplyErg},
Print["doIt:"];
{ptErg,tfErg,plyErg,iplyErg,dplyErg}=smolyakInterpolationPrep[approx,{betterRBCMean,betterRBCSD,betterRBCMinZ,betterRBCMaxZ,betterRBCvv},theDistBetter];
smolRngErg=Transpose[{betterRBCMinZ,betterRBCMaxZ}];
sgSpecErg={toIg,smolRngErg,ptErg,tfErg,plyErg,iplyErg,1,approx,
{betterRBCMean,betterRBCSD,betterRBCMinZ,betterRBCMaxZ,betterRBCvv}};
bmr=ConvexHullMesh[ptErg[[All,{1,2}]]];
rbnds=RegionBounds[bmr];
Print["doIt:sgSpecErg done"];
evs=Eigenvalues[tfErg//N];condNum=evs[[1]]/evs[[-1]];
toIg=aGSpecBetter[[1]];
X0Z0=genX0Z0Funcs[linModBetter];
theFRExt=genFRExtFunc[{4,1,4},linModBetter,{X0Z0,2},eqnsCompiledBetter,
"xVarRanges"->{{0.01,2},{0.01,2},{0.01,20},{0.85,1.2}}];
Print["doIt:theFRExt done"];
DistributeDefinitions[X0Z0,theFRExt,checkPt,getH];
Print["doIt:DistributeDefinitions done"];
(**)
{tm,ig}=Timing[
theRes=parallelNestIterREInterp[genFRExtFunc,linModBetter,
{X0Z0,theK},eqnsCompiledBetter,sgSpecErg,iters,"xVarRanges"->{{0.01,2},{0.01,2},{0.01,20},{0.85,1.2}}]];
(*Print["theRes=",theRes//InputForm];*)
{tmTrad,ig}=Timing[
theResTrad=parallelNestIterREInterp[genFRExtFunc,linModBetter,
{X0Z0,theK},eqnsCompiledBetter,sgSpecErg,iters,"xVarRanges"->{{0.01,2},{0.01,2},{0.01,20},{0.85,1.2}},"Traditional"->True]];
(*Print["theResTrad=",theResTrad//InputForm];*)
numKern=Length[Kernels[]];
theName=fNameString[approx,iters,theK,numKern];
(**)
{tmExactTrad,ig}=Timing[
theResExactTrad=parallelNestIterREInterp[genFRExtFunc,linModBetter,
{simpRBCExactX0Z0CEBetter,theK},eqnsCompiledBetter,sgSpecErg,iters,"xVarRanges"->{{0.01,2},{0.01,2},{0.01,20},{0.85,1.2}},"Traditional"->True]];
Print["theResExtractTrad:"];
Export[theName<>"ExactTrad.pdf",
forDRExactTrad=theResExactTrad[[-1,1]];DistributeDefinitions[forDR];
forDRCEExactTrad=theResExactTrad[[-1,2]];DistributeDefinitions[forDRCE];
ContourPlot[
Norm[actualErrs[forDRExactTrad,
backZtoX[{{z1,z2,0}},betterRBCMean,betterRBCSD,betterRBCvv][[1]]]],
{z1,betterRBCMinZ[[1]],betterRBCMaxZ[[1]]},{z2,betterRBCMinZ[[2]],betterRBCMaxZ[[2]]},PlotRange->All,PlotLegends->Automatic,PlotLabel->theName<>"ExactTrad"]];
Print["ExactTrad"];
(**)
{tmExact,ig}=Timing[
theResExact=parallelNestIterREInterp[genFRExtFunc,linModBetter,
{simpRBCExactX0Z0CEBetter,theK},eqnsCompiledBetter,sgSpecErg,iters,"xVarRanges"->{{0.01,2},{0.01,2},{0.01,20},{0.85,1.2}}]];
Print["theResExtract:"];
Export[theName<>"Exact.pdf",
forDRExact=theResExact[[-1,1]];DistributeDefinitions[forDR];
forDRCEExact=theResExact[[-2,2]];DistributeDefinitions[forDRCE];
ContourPlot[
Norm[actualErrs[forDRExact,
backZtoX[{{z1,z2,0}},betterRBCMean,betterRBCSD,betterRBCvv][[1]]]],
{z1,betterRBCMinZ[[1]],betterRBCMaxZ[[1]]},{z2,betterRBCMinZ[[2]],betterRBCMaxZ[[2]]},PlotRange->All,PlotLegends->Automatic,PlotLabel->theName<>"Exact"]];
Print["Exact"];
(**)
forDR=theRes[[-1,1]];DistributeDefinitions[forDR];
forDRCE=theRes[[-2,2]];DistributeDefinitions[forDRCE];
forDRTrad=theResTrad[[-1,1]];DistributeDefinitions[forDRTrad];
forDRCETrad=theResTrad[[-2,2]];DistributeDefinitions[forDRCETrad];
(**)
Print["doIt:parallelNestGeneric done"];
DistributeDefinitions[linModBetter];
(**)
drerrName=Unique["drerr"];
drerrNameTrad=Unique["drerrTrad"];
(**)
drName=Unique["dr"];
drNameTrad=Unique["drTrad"];
(**)
drName[z1_?NumberQ,z2_?NumberQ,z3_?NumberQ]:=
Module[{},
-Norm[actualErrs[forDR,backZtoX[{{z1,z2,z3}},betterRBCMean,betterRBCSD,betterRBCvv][[1]]]]];
drNameTrad[z1_?NumberQ,z2_?NumberQ,z3_?NumberQ]:=
Module[{},
-Norm[actualErrs[forDRTrad,backZtoX[{{z1,z2,z3}},betterRBCMean,betterRBCSD,betterRBCvv][[1]]]]];
(**)
drerrName[z1_?NumberQ,z2_?NumberQ,z3_?NumberQ]:=
Module[{},
With[{resNow=-Norm[approxErrs[forDR,forDRCE,
backZtoX[{{z1,z2,z3}},betterRBCMean,betterRBCSD,betterRBCvv][[1]]]]},
resNow]];
drerrNameTrad[z1_?NumberQ,z2_?NumberQ,z3_?NumberQ]:=
Module[{},
With[{resNow=-Norm[approxErrs[forDRTrad,forDRCETrad,
backZtoX[{{z1,z2,z3}},betterRBCMean,betterRBCSD,betterRBCvv][[1]]]]},
resNow]];
DistributeDefinitions[drerrName,drName];
DistributeDefinitions[drerrNameTrad,drNameTrad];
(**)tryEps=.03;
acterr={acterrVal,acterrSubs}=NMinimize[drName[z1,z2,z3],
And[betterRBCMinZ[[1]] <=z1<=betterRBCMaxZ[[1]],
betterRBCMinZ[[2]]<=z2<=betterRBCMaxZ[[2]],
betterRBCMinZ[[3]]<=z3<=betterRBCMaxZ[[3]]],{z1,z2,z3},Method->"NelderMead"];
Print["acterr:",acterr];
errBnd={errBndVal,errBndSubs}=NMinimize[drerrName[z1,z2,z3],
And[betterRBCMinZ[[1]] <=z1<=betterRBCMaxZ[[1]],
betterRBCMinZ[[2]]<=z2<=betterRBCMaxZ[[2]],
betterRBCMinZ[[3]]<=z3<=betterRBCMaxZ[[3]]],{z1,z2,z3},Method->"NelderMead"];
Print["errBnd:",errBnd];
acterrTrad={acterrValTrad,acterrSubsTrad}=NMinimize[drNameTrad[z1,z2,z3],
And[betterRBCMinZ[[1]] <=z1<=betterRBCMaxZ[[1]],
betterRBCMinZ[[2]]<=z2<=betterRBCMaxZ[[2]],
betterRBCMinZ[[3]]<=z3<=betterRBCMaxZ[[3]]],{z1,z2,z3},Method->"NelderMead"];
Print["acterrTrad:",acterrTrad];
errBndTrad={errBndValTrad,errBndSubsTrad}=NMinimize[drerrNameTrad[z1,z2,z3],
And[betterRBCMinZ[[1]] <=z1<=betterRBCMaxZ[[1]],
betterRBCMinZ[[2]]<=z2<=betterRBCMaxZ[[2]],
betterRBCMinZ[[3]]<=z3<=betterRBCMaxZ[[3]]],{z1,z2,z3},Method->"NelderMead"];
Print["errBndTrad:",errBndTrad];
(**)
errBndLoc={z1,z2}/.errBndSubs;
acterrLoc={z1,z2}/.acterrSubs;
errBndLocTrad={z1,z2}/.errBndSubsTrad;
acterrLocTrad={z1,z2}/.acterrSubsTrad;
(**)
mthName=theName<>".mth";
If[FileExistsQ[mthName],DeleteFile[mthName]];
(**)
bothErrStr=
"\nerrBnd="<>
(errBndStr=ToString[NumberForm[-errBndVal,NumberFormat->(Row[{#1,"e",#3}]&)]])<>","<>
"actualErr="<>(acterrStr=ToString[NumberForm[-acterrVal,NumberFormat->(Row[{#1,"e",#3}]&)]]);
bothErrStrTrad=
"\nerrBndTrad="<>
(errBndStrTrad=ToString[NumberForm[-errBndValTrad,NumberFormat->(Row[{#1,"e",#3}]&)]])<>","<>
"actualErrTrad="<>(acterrStrTrad=ToString[NumberForm[-acterrValTrad,NumberFormat->(Row[{#1,"e",#3}]&)]]);
(**)
WriteString[theName<>"acterr.tex",acterrStr];
WriteString[theName<>"errBnd.tex",errBndStr];
Print["here",{acterrStr,acterr,errBnd,bothErrStr,errBndVal}];
Print["hereTrad",{acterrStrTrad,acterrTrad,errBndTrad,bothErrStrTrad,errBndValTrad}];
zPts=backXtoZ[ptErg,betterRBCMean,betterRBCSD,betterRBCvv];
Print["errBndLoc=",errBndLoc];
iterPts=
(**)
Export[theName<>".pdf",acterrsCP=
ContourPlot[
Norm[actualErrs[forDR,
backZtoX[{{z1,z2,tryEps}},betterRBCMean,betterRBCSD,betterRBCvv][[1]]]],
{z1,betterRBCMinZ[[1]],betterRBCMaxZ[[1]]},{z2,betterRBCMinZ[[2]],betterRBCMaxZ[[2]]},PlotRange->All,PlotLegends->Automatic,PlotLabel->theName<>bothErrStr,
Epilog->{PointSize[0.05],Green,Point[acterrLoc[[{1,2}]]],PointSize[0.025],Orange,Point[errBndLoc[[{1,2}]]],PointSize[0.0125],Black,Point[#]&/@zPts[[All,{1,2}]]},PlotRangeClipping->False]];
Print["acterrsCP"];
(*
Export[theName<>"Trad"<>".pdf",acterrsTradCP=
ContourPlot[
Norm[actualErrs[forDRTrad,
backZtoX[{{z1,z2,tryEps}},betterRBCMean,betterRBCSD,betterRBCvv][[1]]]],
{z1,betterRBCMinZ[[1]],betterRBCMaxZ[[1]]},{z2,betterRBCMinZ[[2]],betterRBCMaxZ[[2]]},PlotRange->All,PlotLegends->Automatic,PlotLabel->theName<>"Trad"<>bothErrStrTrad,
Epilog->{PointSize[0.05],Green,Point[acterrLocTrad[[{1,2}]]],PointSize[0.025],Orange,Point[errBndLoc[[{1,2}]]],PointSize[0.0125],Black,Point[#]&/@zPts[[All,{1,2}]]},PlotRangeClipping->False]];
Print["acterrsTradCP"];
(**)
Export[theName<>"Minus.pdf",
ContourPlot[
Norm[actualErrs[forDR,
backZtoX[{{z1,z2,-.03}},betterRBCMean,betterRBCSD,betterRBCvv][[1]]]],
{z1,betterRBCMinZ[[1]],betterRBCMaxZ[[1]]},{z2,betterRBCMinZ[[2]],betterRBCMaxZ[[2]]},PlotRange->All,PlotLegends->Automatic,PlotLabel->theName<>"Minus"<>bothErrStr,
Epilog->{PointSize[0.05],Green,Point[acterrLoc[[{1,2}]]],PointSize[0.025],Orange,Point[errBndLoc[[{1,2}]]],PointSize[0.0125],Black,Point[#]&/@zPts[[All,{1,2}]]}]];
Print["Minus"];
Export[theName<>"Plus.pdf",
ContourPlot[
Norm[actualErrs[forDR,
backZtoX[{{z1,z2,.03}},betterRBCMean,betterRBCSD,betterRBCvv][[1]]]],
{z1,betterRBCMinZ[[1]],betterRBCMaxZ[[1]]},{z2,betterRBCMinZ[[2]],betterRBCMaxZ[[2]]},PlotRange->All,PlotLegends->Automatic,PlotLabel->theName<>"Plus"<>bothErrStr,
Epilog->{PointSize[0.05],Green,Point[acterrLoc[[{1,2}]]],PointSize[0.025],Orange,Point[errBndLoc[[{1,2}]]],PointSize[0.0125],Black,Point[#]&/@zPts[[All,{1,2}]]}]];
Print["Plus"];
*)
Export[theName<>"Approx.pdf",
(**)
ContourPlot[
Norm[checkPt[forDR,forDRCE,theK,
backZtoX[{{z1,z2,tryEps}},betterRBCMean,betterRBCSD,betterRBCvv][[1]]]],
{z1,betterRBCMinZ[[1]],betterRBCMaxZ[[1]]},{z2,betterRBCMinZ[[2]],betterRBCMaxZ[[2]]},PlotRange->All,PlotLegends->Automatic,PlotLabel->theName<>"Approx"<>bothErrStr,
Epilog->{PointSize[0.05],Green,Point[acterrLoc[[{1,2}]]],PointSize[0.025],Orange,Point[errBndLoc[[{1,2}]]],PointSize[0.0125],Black,Point[#]&/@zPts[[All,{1,2}]]}]];
Print["Approx"];
Export[theName<>"ApproxTrad.pdf",
ContourPlot[
Norm[checkPt[forDRTrad,forDRCETrad,theK,
backZtoX[{{z1,z2,tryEps}},betterRBCMean,betterRBCSD,betterRBCvv][[1]],"Traditional"->True]],
{z1,betterRBCMinZ[[1]],betterRBCMaxZ[[1]]},{z2,betterRBCMinZ[[2]],betterRBCMaxZ[[2]]},PlotRange->All,PlotLegends->Automatic,PlotLabel->theName<>"ApproxTrad"<>bothErrStr,
Epilog->{PointSize[0.05],Green,Point[acterrLocTrad[[{1,2}]]],PointSize[0.025],Orange,Point[errBndLocTrad[[{1,2}]]],PointSize[0.0125],Black,Point[#]&/@zPts[[All,{1,2}]]}]];
Print["Trad"];
(**)
truncPtFunc[z1_?NumberQ,z2_?NumberQ,z3_?NumberQ]:=
Module[{},
Norm[tErrMat.Transpose[{checkPt[forDR,forDRCE,theK,
backZtoX[{{z1,z2,tryEps}},betterRBCMean,betterRBCSD,betterRBCvv][[1]]]}]]];
Export[theName<>"truncApprox.pdf",
ContourPlot[
truncPtFunc[z1,z2,tryEps],
{z1,betterRBCMinZ[[1]],betterRBCMaxZ[[1]]},{z2,betterRBCMinZ[[2]],betterRBCMaxZ[[2]]},PlotRange->All,PlotLegends->Automatic,PlotLabel->theName<>"TruncApprox"<>bothErrStr,
Epilog->{PointSize[0.05],Green,Point[acterrLoc[[{1,2}]]],PointSize[0.025],Orange,Point[errBndLoc[[{1,2}]]],PointSize[0.0125],Black,Point[#]&/@zPts[[All,{1,2}]]}]];
Print["TruncApprox"];
Save[mthName,theRes,theResTrad,tm,tmTrad,numKern,condNum,
errBndVal,errBndLoc,acterrVal,acterrLoc,
errBndValTrad,errBndLocTrad,acterrValTrad,acterrLocTrad,acterrsCP];
Print["doIt:saving done"];
{theRes,theResTrad}]


getErrs[approx_?VectorQ,iters_Integer,theK_Integer,numKern_Integer]:=
Module[{},
With[{mthName=fNameString[approx,iters,theK,numKern]<>".mth"},
theSave=Get[mthName];
Show[acterrsCP];
{errBnd,errBndLoc,acterr,acterrLoc}]]

approx=1*{1,1,1};
{ptErg,tfErg,plyErg,iplyErg,dplyErg}=smolyakInterpolationPrep[approx,{betterRBCMean,betterRBCSD,betterRBCMinZ,betterRBCMaxZ,betterRBCvv},theDistBetter];
smolRngErg=Transpose[{betterRBCMinZ,betterRBCMaxZ}];
toIg=aGSpecBetter[[1]];
sgSpecErg={toIg,smolRngErg,ptErg,tfErg,plyErg,iplyErg,1,approx,
{betterRBCMean,betterRBCSD,betterRBCMinZ,betterRBCMaxZ,betterRBCvv}};

(*

Plot3D[actualErrs[forDR,{kk,tt,0}][[1]],{kk,rbnds[[1,1]],rbnds[[1,2]]},{tt,rbnds[[2,1]],rbnds[[2,2]]},RegionFunction->Function[{kk,tt,zz},RegionMember[bmr,{kk,tt}]],PlotRange->All]


msntoval=MSNTO[drerrName,
{{ { {{betterRBCMinZ[[1]],betterRBCMaxZ[[1]]},{betterRBCMinZ[[2]],betterRBCMaxZ[[2]]}},{} },{{0},Infinity}}},msntoIters,Nied,.1,1.2,.5];
errBnd=(-1)*pickBestMSNTO[msntoval];errBndLoc=MSNTOMinimizer[msntoval];
Print["done first msnto"];
msntoval=MSNTO[drName,{{ { {{betterRBCMinZ[[1]],betterRBCMaxZ[[1]]},{betterRBCMinZ[[2]],betterRBCMaxZ[[2]]}},{} },{{0},Infinity}}},
msntoIters,Nied,.1,1.2,.5];
Print["done second msnto"];

errKBnd={errKBndVal,errKBndSubs}=NMinimize[drerrKName[z1,z2],
And[betterRBCMinZ[[1]] <=z1<=betterRBCMaxZ[[1]],
betterRBCMinZ[[2]]<=z2<=betterRBCMaxZ[[2]]],{z1,z2},Method->"NelderMead"];Print["errKBnd:",errKBnd];
errKBndLoc={z1,z2}/.errKBndSubs;
errKBnd={errKBndVal,errKBndSubs}=NMinimize[drerrKName[z1,z2],
And[betterRBCMinZ[[1]] <=z1<=betterRBCMaxZ[[1]],
betterRBCMinZ[[2]]<=z2<=betterRBCMaxZ[[2]]],{z1,z2},Method->"NelderMead"];Print["errKBnd:",errKBnd];
errKBndLoc={z1,z2}/.errKBndSubs;


*)
(*
theFRExtGate=genFRExtFunc[{4,1,4},linModBetterTrips,{genX0Z0Funcs[linModBetterTrips],2},eqnsCompiledBetterTrips,"xVarRanges"->{{0.01,2},{0.01,2},{0.01,20},{0.85,1.3}}]

theFRExtNoGate=genFRExtFunc[{4,1,4},linModBetterTrips,{genX0Z0Funcs[linModBetterTrips],2},eqnsCompiledBetterTrips[[1,1,2]],"xVarRanges"->{{0.01,2},{0.01,2},{0.01,20},{0.85,1.3}}]

theFRExtNoGate @@ anXEpsFlatBetter
evaluateTriple[theFRExtGate[[1]],anXEpsFlatBetter]

approx=1*{1,1,1};
{ptErg,tfErg,plyErg,iplyErg,dplyErg}=smolyakInterpolationPrep[approx,{betterRBCMean,betterRBCSD,betterRBCMinZ,betterRBCMaxZ,betterRBCvv},theDistBetter];
smolRngErg=Transpose[{betterRBCMinZ,betterRBCMaxZ}];
toIg=aGSpecBetter[[1]];
sgSpecErg={toIg,smolRngErg,ptErg,tfErg,plyErg,iplyErg,1,approx,
{betterRBCMean,betterRBCSD,betterRBCMinZ,betterRBCMaxZ,betterRBCvv}};

smolyakGenInterpData[theFRExtGate,sgSpecErg]

(* uses triples

X0Z0=genX0Z0Funcs[linModBetter];
theResPNestGT=parallelNestIterREInterp[genFRExtFunc,linModBetter,
{X0Z0,2},eqnsCompiledBetter,aGSpecBetter,theDistBetterTrips,3,"xVarRanges"->{{0.01,2},{0.01,2},{0.01,20},{0.85,1.2}}];

X0Z0=genX0Z0Funcs[linModBetter];
theResPNestST=parallelNestIterREInterp[genFRExtFunc,linModBetter,
{X0Z0,2},eqnsCompiledBetterTrips,sgSpecErg,3,"xVarRanges"->{{0.01,2},{0.01,2},{0.01,20},{0.85,1.2}}];



*)



X0Z0=genX0Z0Funcs[linModBetter];
theResPNestG=parallelNestIterREInterp[genFRExtFunc,linModBetter,
{X0Z0,2},eqnsCompiledBetter,aGSpecBetter,theDistBetterTrips,3,"xVarRanges"->{{0.01,2},{0.01,2},{0.01,20},{0.85,1.2}}];



X0Z0=genX0Z0Funcs[linModBetter];
theResNestGS=nestGenericIterREInterp[genFRExtFunc,linModBetter,
{X0Z0,2},eqnsCompiledBetter,sgSpecErg,smolyakInterpolation,{},3,"xVarRanges"->{{0.01,2},{0.01,2},{0.01,20},{0.85,1.2}}];


X0Z0=genX0Z0Funcs[linModBetter];
theResPNestS=parallelNestIterREInterp[genFRExtFunc,linModBetter,
{X0Z0,2},eqnsCompiledBetter,sgSpecErg,3,"xVarRanges"->{{0.01,2},{0.01,2},{0.01,20},{0.85,1.2}}];

X0Z0=genX0Z0Funcs[linModBetter];
theResPNestGenS=parallelNestGenericIterREInterp[genFRExtFunc,linModBetter,
{X0Z0,2},eqnsCompiledBetter,sgSpecErg,smolyakInterpolation,{},3,"xVarRanges"->{{0.01,2},{0.01,2},{0.01,20},{0.85,1.2}}];

Get["AMAFedsBetterRBC.mth"]
ha=genFRExtFunc[{4,1,4},linModBetter,{simpRBCExactX0Z0CEBetter,,2},eqnsCompiledBetter,"xVarRanges"->{{0.01,2},{0.01,2},{0.01,20},{0.85,1.2}},"Traditional"->True];

Get["AMAFedsBetterRBC.mth"]
ba=genFRExtFunc[{4,1,4},linModBetter,{simpRBCExactX0Z0CEBetter,2},eqnsCompiledBetter,"xVarRanges"->{{0.01,2},{0.01,2},{0.01,20},{0.85,1.2}},"Traditional"->True];


ba=genFRExtFunc[{4,1,4},linModBetter,{simpRBCExactX0Z0CEBetter,2},eqnsCompiledBetter,"xVarRanges"->{{0.01,2},{0.01,2},{0.01,20},{0.85,1.2}},"Traditional"->True];
ba @@ anXEpsFlatBetter

simpRBCExactDRBetter @@ anXEpsFlatBetter

Following has zeros everywhere as it should
ContourPlot[
Norm[simpRBCExactDRBetter[99,z1,99,z2,0]-ba[99,z1,99,z2,0][[Range[4]]]],{z1,.1,.3},{z2,.9,1.1},PlotRange->All,PlotLegends->Automatic]



ba=genFRExtFunc[{4,1,4},linModBetter,{simpRBCExactX0Z0CEBetter,2},eqnsCompiledBetter,"xVarRanges"->{{0.01,2},{0.01,2},{0.01,20},{0.85,1.2}}];
ba @@ anXEpsFlatBetter
simpRBCExactDRBetter @@ anXEpsFlatBetter
Following far from zeros everywhere 
ContourPlot[
Norm[simpRBCExactDRBetter[99,z1,99,z2,0]-ba[99,z1,99,z2,0][[Range[4]]]],{z1,.1,.3},{z2,.9,1.1},PlotRange->All,PlotLegends->Automatic]



ba=genFRExtFunc[{4,1,4},linModBetter,{simpRBCExactX0Z0CEBetter,5},eqnsCompiledBetter,"xVarRanges"->{{0.01,2},{0.01,2},{0.01,20},{0.85,1.2}}];
ba @@ anXEpsFlatBetter
simpRBCExactDRBetter @@ anXEpsFlatBetter
Following closer to  zeros everywhere still away
ContourPlot[
Norm[simpRBCExactDRBetter[99,z1,99,z2,0]-ba[99,z1,99,z2,0][[Range[4]]]],{z1,.1,.3},{z2,.9,1.1},PlotRange->All,PlotLegends->Automatic]


Still differ 50 terms out
ba=genFRExtFunc[{4,1,4},linModBetter,{simpRBCExactX0Z0CEBetter,50},eqnsCompiledBetter,"xVarRanges"->{{0.01,2},{0.01,2},{0.01,20},{0.85,1.2}}];
ba @@ anXEpsFlatBetter
simpRBCExactDRBetter @@ anXEpsFlatBetter

ba=genFRExtFunc[{4,1,4},
linModBetter,
{simpRBCExactX0Z0CEBetter,5},eqnsCompiledBetter,"xVarRanges"->{{0.01,2},{0.01,2},{0.01,20},{0.85,1.2}}];
ba @@ anXEpsFlatBetter
simpRBCExactDRBetter @@ anXEpsFlatBetter
Following closer to  zeros everywhere still away
ContourPlot[
Norm[simpRBCExactDRBetter[99,z1,99,z2,0]-ba[99,z1,99,z2,0][[Range[4]]]],{z1,.1,.3},{z2,.9,1.1},PlotRange->All,PlotLegends->Automatic]


Still differ 50 terms out


SetOptions[FindRoot,WorkingPrecision->50]
ba=genFRExtFunc[{4,1,4},linModBetter,{simpRBCExactX0Z0CEBetter,50},eqnsCompiledBetter,"xVarRanges"->{{0.01,2},{0.01,2},{0.01,20},{0.85,1.2}}];
ba @@ anXEpsFlatBetter
simpRBCExactDRBetter @@ anXEpsFlatBetter

ha=genFRExtFunc[{4,1,4},linModBetter,{simpRBCExactX0Z0CEBetter,50},eqnsCompiledBetter,"xVarRanges"->{{0.01,2},{0.01,2},{0.01,20},{0.85,1.2}},"Traditional"->True];
ha @@ anXEpsFlatBetter
simpRBCExactDRBetter @@ anXEpsFlatBetter


doIt[{1, 1, 1}, 10, 0];
doIt[{1, 1, 1}, 30, 30];
doIt[2*{1, 1, 1}, 30, 30];
doIt[3*{1, 1, 1}, 30, 30];
doIt[4*{1, 1, 1}, 30, 30];
doIt[{1, 1, 1}, 10, 1];
doIt[{1, 1, 1}, 10, 2];
doIt[{1, 1, 1}, 10, 3];
doIt[{1, 1, 1}, 10, 4];
doIt[{1, 1, 1}, 10, 5];

Following produces zeroes everywhere as it should
ContourPlot[
Norm[approxErrs[simpRBCExactDRBetter,simpRBCExactDRCEBetter,
backZtoX[{{z1,z2,0}},betterRBCMean,betterRBCSD,betterRBCvv][[1]]]],
{z1,betterRBCMinZ[[1]],betterRBCMaxZ[[1]]},{z2,betterRBCMinZ[[2]],betterRBCMaxZ[[2]]},PlotRange->All,PlotRangeClipping->False,PlotLegends->Automatic]

series robust way to get close then use traditional to avoid inaccuracy
caused by summation




differ but shouldn't
numVals=0

 simpModBetter = 
  genSeriesReps[ linModBetter,anXEpsBetter, 1, 
   simpRBCExactDRBetter,simpRBCExactDRCEBetter, numVals];

                  
 simpMod = 
  genSeriesReps[ linMod,anXEps, 1, 
   simpRBCExactDR,simpRBCExactCondExp, numVals];

Transpose[{simpModBetter,simpMod}][[Range[1]]]


 simpModBetterZs = 
  genZsREExact[ linModBetter,anXEpsBetter, 1, 
   simpRBCExactDRBetter,simpRBCExactDRCEBetter, numVals];

simpModZs  = 
  genZsREExact[ linMod,anXEps, 1, 
   simpRBCExactDR,simpRBCExactCondExp, numVals];
Transpose[{simpModBetterZs,simpModZs}][[Range[1]]]

iters match
 simpModBetterIter = 
  iterateDRREIntegrate[simpRBCExactDRBetter,simpRBCExactDRCEBetter,anXEpsBetter, 1, numVals+2];

simpModIter  = 
  iterateDRREIntegrate[ 
   simpRBCExactDR,simpRBCExactCondExp,anXEps, 1, numVals+2];
{simpModBetterIter[[4+Range[2*4]]],simpModIter[[3+Range[2*3]]]}


first compomemt of psiC's differ
In[48]:= getPsiC[linMod]

Out[48]= {{-0.998869}, {-0.197184}, {0.0500976}}

In[50]:= getPsiC[linModBetter]//N

Out[50]= {{-3.7735}, {-0.197184}, {2.77741}, {0.0500976}}


match
In[62]:= simpleRBCModel`Private`ssSolnVecRE//N

Out[62]= {{0.360408}, {0.187324}, {1.001}}

In[63]:= betterRBC`Private`ssSolnVecRE//N

Out[63]= {{0.360408}, {0.187324}, {2.77741}, {1.001}}

first and third of hsum differ

In[64]:= betterRBC`Private`hSumRE//N

Out[64]= {{-7.6986, 9.47963, -0.999, 0.}, 
 
>    {1., -0.0526316, 0., -0.547185}, {7.7063, 0., 1., -2.77463}, 
 
>    {0., 0., 0., 0.0500475}}

In[65]:= simpleRBCModel`Private`hSumRE//N

Out[65]= {{0., 9.47963, -2.77186}, {1., -0.0526316, -0.547185}, 
 
>    {0., 0., 0.0500475}}


one z but xtp1 not on lin path (ie two non zero z's)
numVals=0;
 simpModBetterZs = 
  genZsREExact[ linModBetter,anXEpsBetter, 1, 
   simpRBCExactDRBetter,simpRBCExactDRCEBetter, numVals+1];

simpModZs  = 
  genZsREExact[ linMod,anXEps, 1, 
   simpRBCExactDR,simpRBCExactCondExp, numVals+1];

simpModBetterIter = 
  iterateDRREIntegrate[simpRBCExactDRBetter,simpRBCExactDRCEBetter,anXEpsBetter, 1, numVals+2];

simpModIter  = 
  iterateDRREIntegrate[ 
   simpRBCExactDR,simpRBCExactCondExp,anXEps, 1, numVals+2];

getH[linModBetter]. simpModBetterIter - getPhi[linModBetter].simpModBetterZs[[1]]
getH[linMod]. simpModIter - getPhi[linMod].simpModZs[[1]]


{getB[linMod]. anXEps[[Range[3]]]+ getPhi[linMod].simpModZs[[1]]+ Inverse[IdentityMatrix[3]-getF[linMod]].getPhi[linMod].getPsiC[linMod] +  getPhi[linMod].getPsiEps[linMod]*anXEps[[4,1]],simpModIter[[3+Range[3]]]}


{getB[linModBetter]. anXEpsBetter[[Range[4]]]+ getPhi[linModBetter].simpModBetterZs[[1]]+ Inverse[IdentityMatrix[4]-getF[linModBetter]].getPhi[linModBetter].getPsiC[linModBetter] +  getPhi[linModBetter].getPsiEps[linModBetter]*anXEpsBetter[[5,1]],simpModBetterIter[[4+Range[4]]]}//N




two z but then xtp1 on lin path

x0z0Better=genX0Z0Funcs[linModBetter];
x0z0=genX0Z0Funcs[linMod];
numVals=0;
 simpModBetterZs = 
  genZsREExact[ linModBetter,anXEpsBetter, 1, 
   simpRBCExactDRBetter,x0z0Better, numVals+1];

simpModZs  = 
  genZsREExact[ linMod,anXEps, 1, 
   simpRBCExactDR,x0z0, numVals+1];

simpModBetterIter = 
  iterateDRREIntegrate[simpRBCExactDRBetter,x0z0Better,anXEpsBetter, 1, numVals+2];

linXtp2Better=(x0z0Better @@ Flatten[simpModBetterIter[[2*4+Range[4]]]])[[Range[4]]];
newZ2Better=getH[linModBetter]. Join[simpModBetterIter[[4+Range[2*4]]],linXtp2Better]-getPsiC[linModBetter] 



simpModIter  = 
  iterateDRREIntegrate[ 
   simpRBCExactDR,x0z0,anXEps, 1, numVals+2];

linXtp2=(x0z0 @@ Flatten[simpModIter[[2*3+Range[3]]]])[[Range[3]]];
newZ2=getH[linMod]. Join[simpModIter[[3+Range[2*3]]],linXtp2]-getPsiC[linMod] 


{getB[linMod]. anXEps[[Range[3]]]+
getPhi[linMod].simpModZs[[1]]+
getF[linMod].getPhi[linMod].newZ2+
Inverse[IdentityMatrix[3]-getF[linMod]].getPhi[linMod].getPsiC[linMod] +  getPhi[linMod].getPsiEps[linMod]*anXEps[[4,1]],simpModIter[[3+Range[3]]]}


{getB[linModBetter]. anXEpsBetter[[Range[4]]]+
getPhi[linModBetter].simpModBetterZs[[1]]+
getF[linModBetter].getPhi[linModBetter].newZ2Better+
Inverse[IdentityMatrix[4]-getF[linModBetter]].getPhi[linModBetter].getPsiC[linModBetter] +  getPhi[linModBetter].getPsiEps[linModBetter]*anXEpsBetter[[5,1]],simpModBetterIter[[4+Range[4]]]}//N






numVals=0;
 simpModBetterZs = 
  genZsREExact[ linModBetter,anXEpsBetter, 1, 
   simpRBCExactDRBetter,simpRBCExactDRCEBetter, numVals+1];

simpModZs  = 
  genZsREExact[ linMod,anXEps, 1, 
   simpRBCExactDR,simpRBCExactCondExp, numVals+1];

simpModBetterIter = 
  iterateDRREIntegrate[simpRBCExactDRBetter,simpRBCExactDRCEBetter,anXEpsBetter, 1, numVals+2];

simpModIter  = 
  iterateDRREIntegrate[ 
   simpRBCExactDR,simpRBCExactCondExp,anXEps, 1, numVals+2];



{getB[linMod]. anXEps[[Range[3]]]+ getPhi[linMod].simpModZs[[1]]+ Inverse[IdentityMatrix[3]-getF[linMod]].getPhi[linMod].getPsiC[linMod] +  getPhi[linMod].getPsiEps[linMod]*anXEps[[4,1]],simpModIter[[3+Range[3]]]}


{getB[linModBetter]. anXEpsBetter[[Range[4]]]+ getPhi[linModBetter].simpModBetterZs[[1]]+ Inverse[IdentityMatrix[4]-getF[linModBetter]].getPhi[linModBetter].getPsiC[linModBetter] +  getPhi[linModBetter].getPsiEps[linModBetter]*anXEpsBetter[[5,1]],simpModBetterIter[[4+Range[4]]]}//N





ba=genFRExtFunc[{4,1,4},linModBetter,{simpRBCExactX0Z0CEBetter,50},eqnsCompiledBetter,"xVarRanges"->{{0.38,0.40},{0.2,0.211},{2.81,2.82},{1.08,1.108}}];

ha=genFRExtFunc[{4,1,4},linModBetter,{simpRBCExactX0Z0CEBetter,50},eqnsCompiledBetter,"xVarRanges"->{{0.01,2},{0.01,2},{0.01,20},{0.85,1.2}},"Traditional"->True];

sa=genFRExtFunc[{4,1,4},linModBetter,{simpRBCExactX0Z0CEBetter,50},eqnsCompiledBetter,"xVarRanges"->{{0.01,2},{0.01,2},{0.01,20},{0.85,1.2}},"Traditional"->"Both"];
{ba @@ anXEpsFlatBetter,ha @@ anXEpsFlatBetter,sa @@ anXEpsFlatBetter}


*)
