Get["pathSetup.mth"]
Get["AMASeriesRepresentation`"]
Get["emscsToMma`"]
Print["after emscsToMma"]
Get["betterRBCCompSlack`"]
Print["after betterRBCCompSlack"]


fNameStringCS[approx_?VectorQ,iters_Integer,theK_Integer,numKern_Integer]:=
Module[{},
StringReplace[dirNameStringCS[]<>"forBetterRBC-CS-"<>ToString[approx]<>"Iters"<>ToString[iters]<>"theK"<>ToString[theK],{" "->"","{"->"-","}"->"-"}]];




dirNameStringCS[]:=
Module[{},
aDir="resDirCS"<>"-host-"<>$MachineName<>"numKern"<>ToString[numKern]<>"-"<>ToString[Round[AbsoluteTime[]]]<>"/";
CreateDirectory[aDir]]


prepSmolCS[approx_?VectorQ,iters_Integer,theK_Integer]:=
Module[{zPts},
(**)tryEps=0;
LaunchKernels[];numKern=Length[Kernels[]];
theName=fNameStringCS[approx,iters,theK,numKern];
mthName=theName<>".mth";
X0Z0=genX0Z0Funcs[linModBetterCompSlack];
smolStuff=
{ptErg,tfErg,plyErg,iplyErg,dplyErg}=smolyakInterpolationPrep[approx,{betterRBCCSMean,betterRBCCSSD,betterRBCCSMinZ,betterRBCCSMaxZ,betterRBCCSvv},theDistBetterCompSlack];
smolRngErg=Transpose[{betterRBCCSMinZ,betterRBCCSMaxZ}];
toIg=aGSpecBetterCompSlack[[1]];
sgSpecErg={toIg,smolRngErg,ptErg,tfErg,plyErg,iplyErg,1,approx,
{betterRBCCSMean,betterRBCCSSD,betterRBCCSMinZ,betterRBCCSMaxZ,betterRBCCSvv}};
zPts=backXtoZ[ptErg,betterRBCCSMean,betterRBCCSSD,betterRBCCSvv];
{tryEps,numKern,theName,mthName,X0Z0,sgSpecErg,zPts}
]

(*
prepDRDRCE[theRes_List]:=
Module[{forDR,forDRCE,drName,drerrName},
forDR=theRes[[-1,1]];DistributeDefinitions[forDR];
forDRCE=theRes[[-2,2]];DistributeDefinitions[forDRCE];
DistributeDefinitions[linModBetterCompSlack];
(**)
drerrName=Unique["drerr"];
(**)
drName=Unique["dr"];
(**)
drName[z1_?NumberQ,z2_?NumberQ,z3_?NumberQ]:=
Module[{},
-Norm[actualErrs[forDR,backZtoX[{{z1,z2,z3}},betterRBCCSMean,betterRBCCSSD,betterRBCCSvv][[1]]]]];
(**)
drerrName[z1_?NumberQ,z2_?NumberQ,z3_?NumberQ]:=
Module[{},
With[{resNow=-Norm[approxErrs[forDR,forDRCE,
backZtoX[{{z1,z2,z3}},betterRBCCSMean,betterRBCCSSD,betterRBCCSvv][[1]]]]},
resNow]];
DistributeDefinitions[drerrName,drName];
{{forDR,forDRCE},{drName,drerrName}}
]


minActualErr[drName_Symbol]:=
NMinimize[drName[z1,z2,z3],
And[betterRBCCSMinZ[[1]] <=z1<=betterRBCCSMaxZ[[1]],
betterRBCCSMinZ[[2]]<=z2<=betterRBCCSMaxZ[[2]],
betterRBCCSMinZ[[3]]<=z3<=betterRBCCSMaxZ[[3]]],{z1,z2,z3},
{Method->"NelderMead","RandomSeed"->Round[AbsoluteTime[]]}
];

minPredErr[drerrName_Symbol]:=
Module[{errBnd,errBndVal,errBndSubs},
errBnd={errBndVal,errBndSubs}=NMinimize[drerrName[z1,z2,z3],
And[betterRBCCSMinZ[[1]] <=z1<=betterRBCCSMaxZ[[1]],
betterRBCCSMinZ[[2]]<=z2<=betterRBCCSMaxZ[[2]],
betterRBCCSMinZ[[3]]<=z3<=betterRBCCSMaxZ[[3]]],{z1,z2,z3},
{Method->"NelderMead","RandomSeed"->Round[AbsoluteTime[]]}];
{errBndVal,errBndSubs}
]


Options[findMinLocs]={"Traditional"->False}
findMinLocs[theName_String,
drName_Symbol,drerrName_Symbol,opts:OptionsPattern[]]:=
Module[{texModStr,bothErrStr,acterrLoc,errBndLoc,acterr,errBnd,actewrrLoc},
acterr={acterrVal,acterrSubs}=minActualErr[drName];
errBnd={errBndVal,errBndSubs}=minPredErr[drerrName];
errBndLoc={z1,z2,z3}/.errBndSubs;
acterrLoc={z1,z2,z3}/.acterrSubs;
(**)
bothErrStr=
"\nerrBnd="<>
(errBndStr=ToString[NumberForm[-errBndVal,NumberFormat->(Row[{#1,"e",#3}]&)]])<>","<>
"actualErr="<>(acterrStr=ToString[NumberForm[-acterrVal,NumberFormat->(Row[{#1,"e",#3}]&)]]);
texModStr=If[OptionValue["Traditional"],"Trad","Series"];
WriteString[theName<>texModStr<>"acterr.tex",acterrStr];
WriteString[theName<>texModStr<>"errBnd.tex",errBndStr];
{bothErrStr,acterrLoc,errBndLoc,acterr,errBnd}]



Options[errTableRowStr]={"Traditional"->False}
errTableRowStr[approx_?VectorQ,theK_Integer,
{acterr_?NumberQ,_List},{errBnd_?NumberQ,_List},opts:OptionsPattern[]]:=
Module[{
colorQStr=If[(-acterr)>(-errBnd),"\\rowcolor{LightCyan}\n",""]},
colorQStr<>
ToString[approx]<>"&"<>
If[OptionValue["Traditional"],"NA",ToString[theK]]<>"&"<>
ToString[NumberForm[-errBndVal,NumberFormat->(Row[{#1,"e",#3}]&)]]<>"&"<>
ToString[NumberForm[-acterrVal,NumberFormat->(Row[{#1,"e",#3}]&)]]<>"\\\\\n\\hline\n"]




Options[actErrCP]={"Traditional"->False}
actErrCP[forDR_Function,{bothErrStr_String,acterrLoc_List,errBndLoc_List},
zPts_List,theName_String,opts:OptionsPattern[]]:=
Module[{},
ContourPlot[
Norm[actualErrs[forDR,
backZtoX[{{z1,z2,tryEps}},betterRBCCSMean,betterRBCCSSD,betterRBCCSvv][[1]]]],
{z1,betterRBCCSMinZ[[1]],betterRBCCSMaxZ[[1]]},{z2,betterRBCCSMinZ[[2]],betterRBCCSMaxZ[[2]]},PlotRange->All,PlotLegends->Automatic,PlotLabel->StringReplace[theName,"Iters"->"\nIters"
]<>bothErrStr,
Epilog->{PointSize[0.05],Green,Point[acterrLoc[[{1,2}]]],PointSize[0.025],Orange,Point[errBndLoc[[{1,2}]]],PointSize[0.0125],Black,Point[#]&/@zPts[[All,{1,2}]]},PlotRangeClipping->False]]

Options[approxErrCP]={"Traditional"->False}
approxErrCP[forDR_Function,forDRCE_Function,theK_Integer,tryEps_?NumberQ,
{bothErrStr_String,acterrLoc_List,errBndLoc_List},
zPts_List,theName_String,opts:OptionsPattern[]]:=
Module[{},
ContourPlot[
Norm[checkPt[forDR,forDRCE,theK,
backZtoX[{{z1,z2,tryEps}},betterRBCCSMean,betterRBCCSSD,betterRBCCSvv][[1]],FilterRules[{opts},Options[checkPt]]]],
{z1,betterRBCCSMinZ[[1]],betterRBCCSMaxZ[[1]]},{z2,betterRBCCSMinZ[[2]],betterRBCCSMaxZ[[2]]},PlotRange->All,PlotLegends->Automatic,PlotLabel->StringReplace[theName,"Iters"->"\nIters"
]<>"Approx"<>bothErrStr,
Epilog->{PointSize[0.05],Green,Point[acterrLoc[[{1,2}]]],PointSize[0.025],Orange,Point[errBndLoc[[{1,2}]]],PointSize[0.0125],Black,Point[#]&/@zPts[[All,{1,2}]]}]]

*)


Options[doItApproxSeriesCS]={"Traditional"->False}
doItApproxSeriesCS[approx_?VectorQ,iters_Integer,theK_Integer,opts:OptionsPattern[]]:=
Module[{lclMthName,lclName,tryEps,numKern,theName,mthName,X0Z0,sgSpecErg,zPts,tm,ig,theRes,
forDR,forDRCE,drName,drerrName,bothErrStr,acterrLoc,errBndLoc},
{tryEps,numKern,theName,mthName,X0Z0,sgSpecErg,zPts}=
prepSmolCS[approx,iters,theK];
Print["indo:",{Options[parallelNestGenericIterREInterp],FilterRules[{opts},Options[parallelNestGenericIterREInterp]]}];
{tm,ig}=Timing[
theRes=parallelNestGenericIterREInterp[genFRExtFunc,linModBetterCompSlack,
{X0Z0,theK},rbcEqnsBetterCompSlack,sgSpecErg,smolyakInterpolation,{},iters,"xVarRanges"->{{0.01,2},{0.1,4},{0.01,6},{0.01,20},{-5.5,5.5},{0.1,5.5},{0.85,1.2}}(*,FilterRules[{opts},Options[parallelNestGenericIterREInterp]]*)]];
(*
{{forDR,forDRCE},{drName,drerrName}}=prepDRDRCE[theRes];
{bothErrStr,acterrLoc,errBndLoc,acterr,errBnd}=findMinLocs[theName,drName,drerrName,FilterRules[{opts},Options[parallelNestGenericIterREInterp]]];
lclName=If[OptionValue["Traditional"],
theName<>"Trad",
theName<>"Series"
];
lclMthName=If[OptionValue["Traditional"],
StringReplace[mthName,".mth"->"Trad.mth"],
StringReplace[mthName,".mth"->"Series.mth"]
];
WriteString[lclName<>"errTableRow.tex",
errTableRowStr[approx,theK,acterr,errBnd,FilterRules[{opts},Options[checkPt]]]];
Export[lclName<>".pdf",actErrCP[forDR,{bothErrStr,acterrLoc,errBndLoc},zPts,lclName,FilterRules[{opts},Options[actErrCP]]]];
Export[lclName<>"Approx.pdf",
approxErrCP[forDR,forDRCE,theK,tryEps,{bothErrStr,acterrLoc,errBndLoc},zPts,lclName,FilterRules[{opts},Options[approxErrCP]]]];
If[FileExistsQ[mthName],DeleteFile[mthName]];
Save[lclMthName,{lclName,tryEps,numKern,theName,mthName,X0Z0,sgSpecErg,zPts,tm,
theRes,forDR,forDRCE,drName,drerrName,bothErrStr,acterrLoc,errBndLoc}]
*)
{zPts,theRes}
]









(*

X0Z0CompSlack=genX0Z0Funcs[linModBetterCompSlack];


{tryEpsTry,numKernTry,theNameTry,mthNameTry,X0Z0Try,sgSpecErgTry,zPtsTry}=
prepSmolCS[1*{1,1,1},1,2];

filledPts=Map[
Function[xx,Print["parallelSmolyakGenInterpData: parallel maps smolPts",xx];
fillIn[{{},{1,2,4,5,6},xx}]],N[sgSpecErgTry[[3]]]]

theFRTrips=genFRExtFunc[{7,1,7},linModBetterCompSlack,{X0Z0Try,2},
rbcEqnsBetterCompSlack];




{evaluateTriple[theFRTrips[[1,1]],#1],
evaluateTriple[theFRTrips[[1,2]],#1]}&/@ filledPts

iDat=smolyakGenInterpData[theFRTrips,sgSpecErgTry];

smolyakGenInterpData[theFRTrips,sgSpecTry]
parallelSmolyakGenInterpData[theFRTrips,sgSpecErgTry]

tryFunc=makeSmolyakInterpFuncs[theFRTrips,sgSpecErgTry]

parallelMakeGenericInterpFuncs[theFRTrips,{},sgSpecTry,smolyakInterpolation,{}]



ap=3*{1,1,1};
smolRng=#[[{2,3}]]&/@Drop[aGSpecBetterTry,2][[1]];
{pt,tf,ply,iply,dply}=smolyakInterpolationPrep[ap,smolRng,theDistBetterTry];
toIg=aGSpecBetterTry[[1]];
sgSpecTry={toIg,smolRng,pt,tf,ply,iply,1,ap,{}};



parallelDoGenericIterREInterp[genFRExtFunc,
linModBetterTry,{X0Z0Try,5},
rbcEqnsBetterTry,sgSpecTry,
smolyakInterpolation,{}]

(*



*)

hey=parallelNestGenericIterREInterp[genFRExtFunc,
linModBetterCompSlack,{X0Z0CompSlack,20},
rbcEqnsBetterCompSlack,sgSpecCompSlack,
smolyakInterpolation,{},15];

<<JavaGraphics`
Plot3D[{.363318,(hey[[-1,2]][99,99,kk,99,99,99,tt])[[2]]},{kk,betterRBCCompSlack`Private`kLow,betterRBCCompSlack`Private`kHigh},{tt,0.9,1.1},PlotRange->All]

boo=doItApproxSeriesCS[2*{1,1,1},1,5];
anAugDR=boo[[2,2,1]];
anAugDRCE=boo[[2,2,2]];
ha=simulateBetterRBCCS[anAugDR,20000];
justKT01=ha[[All,{3,7}]];


betterRBCCSMean01=Mean[justKT01];
betterRBCCSSD01=StandardDeviation[justKT01];

normedRes01=(#/betterRBCCSSD01)&/@((#-betterRBCCSMean01)&/@justKT01);
{uu01,ss01,vv01}=SingularValueDecomposition[normedRes01];
zz=normedRes01 .vv01;
betterRBCCSMinZ01=Min/@Transpose[zz];
betterRBCCSMaxZ01=Max/@Transpose[zz];
{ig,ig,theKs01,ig,ig,ig,theThetas01}=Transpose[ha];

betterRBCCSMean01=Append[betterRBCCSMean01,0];
betterRBCCSSD01=Append[betterRBCCSSD01,sigVal];
betterRBCCSMinZ01=Append[betterRBCCSMinZ01,-3];
betterRBCCSMaxZ01=Append[betterRBCCSMaxZ01,3];
betterRBCCSvv01=ArrayFlatten[{{ArrayFlatten[{{vv01,{{0},{0}}}}]},{{{0,0,1}}}}];

chkBounded[


*)
