PrependTo[$Path,"../../mathAMA/NumericAMA"];
PrependTo[$Path,"../../mathAMA/SymbolicAMA"];
PrependTo[$Path,"../../ProtectedSymbols"];
Needs["NumericAMA`"]
Needs["SymbolicAMA`"]
Needs["AMASeriesRepresentation`"]


theHMatArb={
{.1,.5,-.5,1.,.4,.9,1.,1.,.9},
{.2,.2,-.5,7.,.4,.8,3.,2.,.6},
{.1,-.25,-1.5,2.1,.47,1.9,2.1,2.1,3.9}
}
{azfHf,atm,aliltmLilJs,aevlsLilevcs,aqmat,BBArb,ansmat,ans0inv}=numericAMA[theHMatArb,1,0]//Chop;



{ig,phiArb,FFArb}=numericComputeBPhiF[theHMatArb,aqmat]//Chop;
psiEpsArb=IdentityMatrix[3];
psiZArb=IdentityMatrix[3];
ssVal={{.2},{-.3},{.5}}(*{{cc},{kk},{theta}}//.Private`ssSolnSubs/.Private`paramSubs//N*)
psiCArb=(theHMatArb . Join[ssVal,ssVal,ssVal])


notLinMod={theHMatArb,BBArb // N, phiArb // N, 
    FFArb // N, psiEpsArb // N, 
    psiCArb // N, psiZArb // N,{{0}}};

notX0Z0=genX0Z0Funcs[notLinMod];



Export["refHmat.pdf", MatrixForm[theHMatArb]];
Export["refBmat.pdf", MatrixForm[BBArb]];
Export["refPhimat.pdf", MatrixForm[phiArb]];
Export["refFmat.pdf", MatrixForm[FFArb]];


occDir="../../../paperProduction/occBind/docs/"
toOccDir[fName_String]:=CopyFile[fName,occDir <>fName,OverwriteTarget -> True];
toOccDir/@{
"refHmat.pdf","refBmat.pdf","refPhimat.pdf","refFmat.pdf"
};

Get["arbGenPath.mth"]


linModArb={theHMatArb,BBArb,phiArb,FFArb,psiEpsArb,psiCArb,psiZArb,psiZPreCompArb={{}}};
exmplLen=150;
initX={10,10,10};
theEpsVal={5,5,5};
somePts=Transpose[Partition[somePtsFlat=genXPath[initX,theEpsVal,exmplLen],3]];
someZs=Join[
		Partition[genZsFromPath[linModArb,somePtsFlat,theEpsVal],3],
		ConstantArray[0,{1,3,1}]];

bunchSeries=Private`genASeriesRep[linModArb,Join[initX,theEpsVal],someZs,#]&/@Range[Length[someZs]];





maxInit=.001;
arbXNorm=Max[maxInit*10,4,maxInit];
arbTruncErr[kk_Integer]:=
		Norm[Inverse[IdentityMatrix[3]-FFArb] .
					MatrixPower[FFArb,kk+1].phiArb .psiZArb] *(
		Norm[theHMatArb[[All,Range[3]]],Infinity]+
		Norm[theHMatArb[[All,3+Range[3]]],Infinity]+
		Norm[theHMatArb[[All,6+Range[3]]],Infinity])*arbXNorm;


theArbErrNorms=Norm[somePts[[All,2]]-Flatten[#[[{4,5,6}]]],Infinity]&/@
				   bunchSeries;
theArbErrNormMaxs=arbTruncErr/@Range[Length[bunchSeries]];
			
Export["arbTruncErr.pdf",
	   ListPlot[{theArbErrNorms,theArbErrNormMaxs},
				PlotJoined->True,PlotRange->All,
	   PlotLabel->"Truncation Error Bound and Actural Error"]];

Export["piPath.pdf",ListPlot[somePts[[1]],PlotJoined->True,PlotLabel->"Pi Digits Path("<>ToString[initX]<>","<>ToString[theEpsVal]<>")"]];
Export["oscillPath.pdf",ListPlot[somePts[[2]],PlotJoined->True,PlotLabel->"Oscillatory Path("<>ToString[initX]<>","<>ToString[theEpsVal]<>")"]];
Export["pseudoPath.pdf",ListPlot[somePts[[3]],PlotJoined->True,PlotLabel->"Pseudo Random Path("<>ToString[initX]<>","<>ToString[theEpsVal]<>")"]];

Export["theZs.pdf",
	   ListPlot[Transpose[Partition[Flatten[someZs],3]],PlotJoined->True,PlotLabel->"z's for  Path("<>ToString[initX]<>","<>ToString[theEpsVal]<>")"]];

